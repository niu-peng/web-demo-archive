<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saturn Particle System v3.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: rgba(255, 255, 255, 0.85);
            pointer-events: none;
        }
        h1 { font-size: 1.5rem; margin: 0; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 1.0rem; margin-top: 5px; opacity: 0.6; }
        p1 { font-size: 1.0rem; margin-top: 0px; opacity: 0.3; }
        
        #status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 20;
            font-size: 1.2rem;
            text-align: center;
            background: rgba(0,0,0,0.5);
            padding: 50px 100px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            transition: opacity 0.5s;
            line-height: 1.5;
        }

        /* 鉴权成功窗口样式 */
        #auth-success {
            border: 1px solid rgba(0, 255, 100, 0.5);
        
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(0, 255, 100, 0.5);
            z-index: 20;
            font-size: 1.2rem;
            text-align: center;
            background: rgba(0,50,0,0.3);
            padding: 50px 100px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            line-height: 1.5;
            /* 初始状态为完全透明 */
            opacity: 0;
            /* 禁止交互 */
            pointer-events: none;
            /* 添加过渡动画 */
            transition: opacity 0.8s ease-in-out;
            display: none;
        }

        #fs-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255,255,255,0.6);
            padding: 8px 16px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: auto;
        }
        #fs-btn:hover { background: rgba(255, 255, 255, 0.2); color: white; }

        /* 修复：使用透明度隐藏视频，防止浏览器停止渲染 */
        .input_video {
            position: absolute;
            top: 0; left: 0;
            width: 1px; height: 1px;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Saturn Kinetic v3.0</h1>
        <p>Interactive Particle Simulation</p>
        <p1>Nekoshark 2025.12.8</p1>
    </div>

    <div id="status">正在初始化摄像头与神经模型...<br><span style="font-size:0.9rem; opacity:0.5">等待授权</span></div>

    <!-- 新增的鉴权成功窗口 -->
    <div id="auth-success">鉴权成功</div>
    
    <button id="fs-btn">Enter Fullscreen</button>

    <div id="canvas-container"></div>
    <video class="input_video"></video>

    <!-- Import Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // ------------------------------------------------------------------
        // 1. Config & State
        // ------------------------------------------------------------------
        const config = {
            particleCount: 160000,
            starCount: 8000, // 减少星星数量 (改进点 2)
            tilt: 10 * (Math.PI / 180),
            baseCamZ: 75,
            // 默认闲置状态
            defaultZoom: 0.25, 
            defaultRotX: 0.1,
            defaultRotY: 0
        };

        const state = {
            targetZoom: config.defaultZoom,
            currentZoom: config.defaultZoom,
            targetRotX: config.defaultRotX,
            targetRotY: config.defaultRotY,
            currentRotX: config.defaultRotX,
            currentRotY: config.defaultRotY,
            handDetected: false,
            lastHandTime: 0
        };

        let scene, camera, renderer, composer;
        let saturnSystem, saturnParticles, starSystem;
        let material;
        let time = 0;

        // ------------------------------------------------------------------
        // 2. Initialization
        // ------------------------------------------------------------------
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, config.baseCamZ);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            
            // Bloom 设置：轻微辉光，避免过曝
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.3; 
            bloomPass.strength = 1.0; 
            bloomPass.radius = 0.2;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize, false);
        }

        // ------------------------------------------------------------------
        // 3. Background Stars (改进点 2：循环球体分布)
        // ------------------------------------------------------------------
        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.starCount * 3);
            const sizes = new Float32Array(config.starCount);
            const colors = new Float32Array(config.starCount * 3);

            const r = 500; // 星球半径

            for (let i = 0; i < config.starCount; i++) {
                // 球面均匀分布算法
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                
                // 随机深度，让星星有层次感 (500 ~ 900)
                const dist = r + Math.random() * 400;

                positions[i*3] = dist * Math.sin(phi) * Math.cos(theta);
                positions[i*3+1] = dist * Math.sin(phi) * Math.sin(theta);
                positions[i*3+2] = dist * Math.cos(phi);

                sizes[i] = Math.random() * 1.5;

                // 极暗淡的颜色，避免抢镜
                const brightness = 0.75 + Math.random() * 0.75; 
                colors[i*3] = brightness;
                colors[i*3+1] = brightness;
                colors[i*3+2] = brightness + 0.05;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starMaterial = new THREE.PointsMaterial({
                size: 1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6, // 降低整体不透明度
                sizeAttenuation: true
            });

            starSystem = new THREE.Points(geometry, starMaterial);
            scene.add(starSystem);
        }

        // ------------------------------------------------------------------
        // 4. Saturn Particle System
        // ------------------------------------------------------------------
        function createSaturn() {
            saturnSystem = new THREE.Group();
            scene.add(saturnSystem);

            const particleCount = config.particleCount;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const orbitData = new Float32Array(particleCount * 3); 
            const randomness = new Float32Array(particleCount * 3); 

            const colorCore = new THREE.Color(0xffcd80);
            const colorRingInner = new THREE.Color(0xdab595); 
            const colorRingOuter = new THREE.Color(0x6e7f99); 

            for (let i = 0; i < particleCount; i++) {
                let r;
                const isCore = Math.random() < 0.125; //星体粒子比例

                if (isCore) {
                    const u = Math.random();
                    const v = Math.random();
                    const theta_s = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    
                    // 修改1：固定半径，形成球壳
                    const baseRadius = 7.5;
                    const thickness = 0.5; // 球壳厚度，可以调整
                    
                    // 方法1：完全均匀的薄球壳（厚度为0）
                    // const rad = baseRadius;
                    
                    // 方法2：有一定厚度的球壳（推荐，视觉效果更好）
                    const rad = baseRadius + (Math.random() - 0.5) * thickness;
                    
                    // 方法3：内球壳（内部空心）
                    // const rad = baseRadius + Math.random() * thickness; // 只在表面
                    
                    // 方法4：多层球壳（更复杂的结构）
                    // const layer = Math.floor(Math.random() * 3); // 0,1,2层
                    // const rad = baseRadius + layer * 0.4 + Math.random() * 0.2;

                    orbitData[i * 3] = rad * 0.5;
                    orbitData[i * 3 + 1] = Math.random() * Math.PI * 2;
                    orbitData[i * 3 + 2] = 0.0;

                    // 使用球面坐标生成粒子位置
                    positions[i*3] = rad * Math.sin(phi) * Math.cos(theta_s);
                    positions[i*3+1] = rad * Math.sin(phi) * Math.sin(theta_s);
                    positions[i*3+2] = rad * Math.cos(phi);

                    // 可以调整核心粒子的颜色，突出球壳效果
                    const shellColor = new THREE.Color(0xffcd80);
                    // 根据半径添加渐变效果
                    const radiusFactor = (rad - (baseRadius - thickness/2)) / thickness;
                    shellColor.multiplyScalar(0.8 + radiusFactor * 0.4);
                    
                    colors[i*3] = shellColor.r;
                    colors[i*3+1] = shellColor.g;
                    colors[i*3+2] = shellColor.b;
                    
                    // 调整粒子大小，球壳可以小一些，显得更精致
                    sizes[i] = Math.random() * 1.5; // 原来是2.5
                    
                    orbitData[i * 3] = rad * 0.5; 
                    orbitData[i * 3 + 1] = Math.random() * Math.PI * 2;
                    orbitData[i * 3 + 2] = 0.0; 

                    positions[i*3] = rad * Math.sin(phi) * Math.cos(theta_s);
                    positions[i*3+1] = rad * Math.sin(phi) * Math.sin(theta_s);
                    positions[i*3+2] = rad * Math.cos(phi);

                    colors[i*3] = colorCore.r;
                    colors[i*3+1] = colorCore.g;
                    colors[i*3+2] = colorCore.b;
                    sizes[i] = Math.random() * 2.5; 
                } else {
                    let rad = 11 + Math.random() * 25;
                    if (rad > 20 && rad < 22) rad += 3;

                    r = rad;
                    const theta = Math.random() * Math.PI * 2;
                    const keplerSpeed = 45.0 / Math.sqrt(rad); 

                    orbitData[i * 3] = rad;
                    orbitData[i * 3 + 1] = theta;
                    orbitData[i * 3 + 2] = keplerSpeed;

                    positions[i*3] = Math.cos(theta) * rad;
                    positions[i*3+1] = (Math.random() - 0.5) * 0.3; 
                    positions[i*3+2] = Math.sin(theta) * rad;

                    const lerpFactor = (rad - 11) / 25;
                    const c = new THREE.Color().lerpColors(colorRingInner, colorRingOuter, lerpFactor);
                    
                    colors[i*3] = c.r;
                    colors[i*3+1] = c.g;
                    colors[i*3+2] = c.b;
                    sizes[i] = Math.random() * 1.5;
                }

                randomness[i*3] = (Math.random() - 0.5) * 2;
                randomness[i*3+1] = (Math.random() - 0.5) * 2;
                randomness[i*3+2] = (Math.random() - 0.5) * 2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('orbitData', new THREE.BufferAttribute(orbitData, 3));
            geometry.setAttribute('randomness', new THREE.BufferAttribute(randomness, 3));

            const vertexShader = `
                uniform float uTime;
                uniform float uZoom; 
                
                attribute float size;
                attribute vec3 color;
                attribute vec3 orbitData; 
                attribute vec3 randomness;

                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vColor = color;
                    
                    float radius = orbitData.x;
                    float initialAngle = orbitData.y;
                    float speed = orbitData.z;
                    
                    vec3 finalPos;
                    
                    if(radius < 8.0) {
                        // 保持整体旋转
                        float rotSpeed = 0.5;
                        float c = cos(uTime * rotSpeed);
                        float s = sin(uTime * rotSpeed);
                        
                        vec3 rotatedPos = vec3(
                            position.x * c + position.z * s,
                            position.y,
                            -position.x * s + position.z * c
                        );
                        
                        // 添加轻微的径向脉动，让球壳更生动
                        float pulse = sin(uTime * 2.0 + radius * 10.0) * 0.05;
                        finalPos = rotatedPos * (1.0 + pulse);
                    } else {
                        float currentAngle = initialAngle + (speed * 0.05 * uTime);
                        finalPos = vec3(
                            cos(currentAngle) * radius,
                            position.y,
                            sin(currentAngle) * radius
                        );
                    }

                    // 缩放逻辑
                    float targetScale = mix(0.2, 3.5, uZoom); // 缩小态更小 (0.2)
                    
                    // 改进点 3: 混沌渐变逻辑
                    // 使用 pow 函数，使混沌在前期几乎为0，只在后期迅速上升
                    float chaosCurve = pow(uZoom, 3.0); 
                    
                    // 削弱混沌幅度，使其更像是一种震动而非乱飞
                    vec3 chaosOffset = randomness * sin(uTime * 25.0 + radius) * (radius * 0.02); 
                    
                    // 只有在 Zoom > 0.5 时才开始介入混沌，且非常微弱
                    vec3 posWithChaos = finalPos + (chaosOffset * chaosCurve * 2.0);
                    
                    // 轻微的炸开效果
                    if(chaosCurve > 0.1) {
                         posWithChaos += normalize(finalPos) * chaosCurve * 1.5;
                    }

                    vec4 mvPosition = modelViewMatrix * vec4(posWithChaos * targetScale, 1.0);
                    
                    // 改进点 1: 捏合时的亮度与尺寸控制
                    // 尺寸衰减：距离越远越小
                    gl_PointSize = size * (250.0 / -mvPosition.z);
                    
                    // 关键：当捏合(uZoom接近0)时，强制减小粒子尺寸，防止聚集成白块
                    gl_PointSize *= (0.4 + uZoom * 0.8);

                    gl_Position = projectionMatrix * mvPosition;

                    // 改进点 1: 亮度逻辑
                    // 捏合时(0.0) -> 亮度极低(0.05)
                    // 张开时(1.0) -> 亮度正常(1.0)
                    float brightness = 0.03 + pow(uZoom, 1.5) * 0.97; 
                    vAlpha = brightness;
                }
            `;

            const fragmentShader = `
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    float dist = length(coord);
                    
                    if(dist > 0.5) discard;
                    
                    // 更锐利的边缘，配合低Alpha实现精致感
                    float alphaShape = 1.0 - smoothstep(0.0, 0.5, dist);
                    
                    gl_FragColor = vec4(vColor, vAlpha * alphaShape);
                }
            `;

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uZoom: { value: 0 },
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            saturnParticles = new THREE.Points(geometry, material);
            saturnParticles.rotation.z = config.tilt;
            saturnParticles.rotation.x = 10 * (Math.PI / 180);

            saturnSystem.add(saturnParticles);
        }

        // ------------------------------------------------------------------
        // 5. MediaPipe Logic (Fixed ReferenceError & Auto Reset)
        // ------------------------------------------------------------------

        let authSuccessShown = false;

        function initMediaPipe() {
            const statusDiv = document.getElementById('status'); // 修复报错
            const authSuccessDiv = document.getElementById('auth-success');
            const videoElement = document.getElementsByClassName('input_video')[0];
            
            function onResults(results) {
                // 只有当状态窗口还在显示时才执行
                if (statusDiv.style.opacity !== '0') {
                    statusDiv.style.opacity = 0; // 淡出原有状态窗口
                    
                    // 延迟执行，让淡出动画完成
                    setTimeout(() => {
                        // 隐藏原状态窗口（可选，防止遮挡）
                        statusDiv.style.display = 'none';
                        
                        // 只有当鉴权成功还没显示过，才显示
                        if (!authSuccessShown) {
                            authSuccessShown = true;
                            
                            // 显示鉴权成功窗口
                            authSuccessDiv.style.display = 'block'; // 先显示元素
                            // 强制浏览器重绘，确保动画生效
                            void authSuccessDiv.offsetWidth;
                            authSuccessDiv.style.opacity = 1;
                            
                            // 1秒后淡出
                            setTimeout(() => {
                                authSuccessDiv.style.opacity = 0;
                                
                                // 淡出完成后，隐藏并禁用交互
                                setTimeout(() => {
                                    authSuccessDiv.style.display = 'none';
                                }, 800); // 等待淡出动画完成
                            }, 1000); // 停留1秒
                        }
                    }, 150); // 等待原有状态窗口淡出完成（0.5秒）
                }
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    state.handDetected = true;
                    state.lastHandTime = Date.now();

                    const landmarks = results.multiHandLandmarks[0];
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    const wrist = landmarks[0];
                    const indexMCP = landmarks[5];

                    const dist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
                    const palmSize = Math.sqrt(Math.pow(wrist.x - indexMCP.x, 2) + Math.pow(wrist.y - indexMCP.y, 2));
                    
                    let ratio = dist / palmSize;
                    let normalized = (ratio - 0.2) / 0.9; 
                    state.targetZoom = Math.max(0, Math.min(1, normalized));

                    const handX = wrist.x; 
                    const handY = wrist.y;
                    
                    //state.targetRotY = (handX - 0.5) * 2.0; 
                    const offset = 0.8;
                    state.targetRotX = (handY - offset) * 2.0;  // 保持相同的旋转幅度

                } else {
                    state.handDetected = false;
                    
                    // 改进点 4: 丢失手势后，平滑回归默认状态
                    // 当手离开超过 500ms 后开始复位
                    if (Date.now() - state.lastHandTime > 500) {
                        state.targetZoom = config.defaultZoom;
                        state.targetRotX = config.defaultRotX;
                        state.targetRotY = config.defaultRotY;
                    }
                }
            }

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640,
                height: 480
            });
            
            cameraUtils.start().catch(e => {
                statusDiv.innerHTML = "鉴权失败: 无法启动摄像头<br>" + 
                                    "<span style='font-size:0.9rem; opacity:0.7'>" + e.message + "</span>";
                
                // 修改文字颜色为红色
                statusDiv.style.color = "rgba(255, 85, 85, 0.5)"; // 亮红色
                statusDiv.style.border = "2px solid rgba(255, 85, 85, 0.5)"; // 红色边框
                statusDiv.style.background = "rgba(50, 0, 0, 0.3)"; // 深红色背景
                statusDiv.style.opacity = "1"; // 确保显示
                statusDiv.style.display = "block"; // 确保显示
                
                console.error(e);
            });
        }

        // ------------------------------------------------------------------
        // 6. Animation
        // ------------------------------------------------------------------
        function animate() {
            requestAnimationFrame(animate);
            time += 0.005; // 略微减慢时间流速，更有质感

            // 平滑过渡算法 (Lerp)
            // 速度系数 0.05 意味着从当前值到目标值是一个渐进过程
            state.currentZoom += (state.targetZoom - state.currentZoom) * 0.05;
            state.currentRotX += (state.targetRotX - state.currentRotX) * 0.05;
            state.currentRotY += (state.targetRotY - state.currentRotY) * 0.05;

            if (saturnSystem) {
                saturnSystem.rotation.y = state.currentRotY; 
                saturnSystem.rotation.x = state.currentRotX;
            }

            if(material) {
                material.uniforms.uTime.value = time;
                material.uniforms.uZoom.value = state.currentZoom;
            }

            // 星空自转 (改进点 2: 无论如何旋转都是循环的，因为是球体中心自转)
            if(starSystem) {
                starSystem.rotation.y = time * 0.01; 
                starSystem.rotation.x = time * 0.005;
            }

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        document.getElementById('fs-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        });

        // Start
        initThree();
        createStars();
        createSaturn();
        initMediaPipe();
        animate();

    </script>
</body>
</html>